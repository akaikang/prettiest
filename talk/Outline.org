* Intro

- Typesetting is critically sensitive to small changes: every saved
  line counts

- Pretty printing (and typesetting in general) is cahotic (if you
  change something towards the beginning it may have non-linear
  effects way down the document)

- It's hard to be greedy (decide locally) and pretty.

* Example
Assume that an s-expr can be pretty-printed either horizontally or
vertically:

#+BEGIN_EXAMPLE
(a b c d)
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
(a
 b
 c
 d)
#+END_EXAMPLE

Recall
#+BEGIN_SRC haskell
data SExpr = SExpr [SExpr] | Atom String
  deriving Show
#+END_SRC

* What I want
Pretty printing ((abcde ((a b c d) (a b c d) (a b c d) (a b c d) (a b
c d))) (abcdefgh ((a b c d) (a b c d) (a b c d) (a b c d) (a b c d))))
on 20-column page should yield:

#+BEGIN_EXAMPLE
12345678901234567890

((abcde ((a b c d)
         (a b c d)
         (a b c d)
         (a b c d)
         (a b c d)))
 (abcdefgh
  ((a b c d)
   (a b c d)
   (a b c d)
   (a b c d)
   (a b c d))))
#+END_EXAMPLE

* State of the pop-art: Hughes

- Greedily fit stuff on the line

#+BEGIN_EXAMPLE
12345678901234567890

((abcde ((a b c d)
         (a b c d)
         (a b c d)
         (a b c d)
         (a b c d)))
 (abcdefgh ((a
             b
             c
             d)
            (a
             b
             c
             d)
            (a
             b
             c
             d)
            (a
             b
             c
             d)
            (a
             b
             c
             d))))
#+END_EXAMPLE

* State of the pop-art: Wadler

#+BEGIN_EXAMPLE
12345678901234567890

((abcde
  ((a b c d)
   (a b c d)
   (a b c d)
   (a b c d)
   (a b c d)))
 (abcdefgh
  ((a b c d)
   (a b c d)
   (a b c d)
   (a b c d)
   (a b c d))))
#+END_EXAMPLE

- will waste a line here and there
- lack of "hang" feature

* I am not satisfied
Remember what I want:

#+BEGIN_EXAMPLE
((abcde ((a b c d)
         (a b c d)
         (a b c d)
         (a b c d)
         (a b c d)))
 (abcdefgh
  ((a b c d)
   (a b c d)
   (a b c d)
   (a b c d)
   (a b c d))))
#+END_EXAMPLE

- Greedy can't be pretty.

* Laws of Pretty-Printing (paraphrased)
What do I really want?

1. A pretty-printer shall not print beyond the right margin
2. A pretty-printer shall reveal the structure of the input
3. A pretty-printer shall use as few lines as possible

   - Hughes breaks 3.
   - Wadler breaks 2.

* What does rule 2 really mean?
- Recall rule 2: "A pretty-printer shall reveal the structure of the input"
- User-specified
- But it is clear that everyone (except perhaps Phil Wadler) wants to
  be able to express vertical alignment after an arbitrary document.

* Describing rule-2 layouts
#+BEGIN_SRC haskell
class Layout l where
  text    :: String -> l
  (<>)    :: l -> l -> l
  flush   :: l -> l
  (<|>)   :: l -> l -> l
#+END_SRC

* Example:
#+BEGIN_SRC haskell
pretty :: Doc d => SExpr -> d
pretty  (Atom s)    = text "(" <>
                      (sep $ map pretty xs) <>
                      text ")"

sep :: Doc d => [d] -> d
sep []  = empty
sep xs  = hsep xs <|> vcat xs

hsep,vcat :: Doc d => [d] -> d
vcat  = foldDoc ($$)
hsep  = foldDoc (<+>)

foldDoc :: Doc d => (d -> d -> d) -> [d] -> d
foldDoc _ []      = empty
foldDoc _ [x]     = x
foldDoc f (x:xs)  = f x (foldDoc f xs)
#+END_SRC

* Semantics (1)
#+BEGIN_SRC haskell
type L = [String] -- non empty.

instance Layout L where
  render :: L -> String
  render = intercalate "\n"
  text :: String -> L
  text s = [s]
  (<>) :: L -> L -> L
  xs <> (y:ys) = xs0 ++ [x ++ y] ++ map (indent ++) ys
     where  xs0 = init xs
            x :: String
            x = last xs
            n = length x
            indent = replicate n ' '
  flush :: L -> L
  flush xs = xs ++ [""]

xs $$ ys = flush xs <> ys
#+END_SRC

* Semantics (2)

#+BEGIN_SRC haskell
instance Layout [L] where
  text = pure . text
  flush = fmap flush
  xs <> ys = (<>) <$> xs <*> ys
  xs <|> ys = (xs ++ ys)
#+END_SRC

* Performance
- The above is an executable specification.

- It has unacceptable performance: every choice induces two layouts.
  Printing any document with >20 disjunctions is unrealistic.

* Making it fast (1b): consider the useful parts only
The choice of layout depends only on 3 parameters: width, height the
width of the last line.


#+BEGIN_EXAMPLE
             width
         <---------------->
         xxxxxxxxxxxxxxxxxx ^
         xxxxxxxxxxxxxxxxxx |  height
         xxxxxxxxxxxxxxxxxx v
         xxxxxxx
         <----->
        last width
#+END_EXAMPLE

* Making it fast (1b): consider the useful parts only
#+NAME: fig:cat
#+CAPTION: Concatenation
#+ATTR_ORG: :width 600
[[file:HCat.png]]

* Making it fast (2): discard dominated results

/a/ dominates /b/ iff. /a/ is smaller than /b/ in all three dimensions

If /a/ dominates /b/, then for any context ctx,

   /ctx a/  dominates  /ctx b/

So, at any point we can discard all dominated layouts from the set of
possible layouts.

(proof in the paper)

* Experimental Results (asymptotic, balanced sexprs)
#+NAME: fig:balanced
#+CAPTION: Balanced tree
#+ATTR_ORG: :width 600
[[file:Balanced.png]]

* Experimental Results (asymptotic, random sexprs)
#+NAME: fig:random
#+CAPTION: Balanced tree
#+ATTR_ORG: :width 600
[[file:Random.png]]

* Experimental Results (absolute)

Render time in seconds:

| Input      |  Mine | Wadler-Leijen | Hughes-PJ |
|------------+-------+---------------+-----------|
| JSON   1k  |   9.7 |           1.5 |       3.0 |
| JSON   10k | 145.5 |          14.8 |      30.0 |
| XML    1k  |  20.0 |           3.2 |      11.9 |
| XML    10k | 245.0 |          36.1 |     192.0 |

* Conclusion

- Pretty-printing is not suited to greedy approach
- Yet, Hughes, Wadler went for a greedy algorithm.
- I suspect that they had a solution in mind *before* they start their
  program derivation.
- (Or worse: mechanical program derivation drove the specification)
- This is an attempt to do a more realistic FP pearl: bridge the gap
  between what actually goes on in programming (graphical models,
  worry about difficult parts only) and program calculation
