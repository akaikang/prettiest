* Intro

- Typesetting is cahotic (if you change something towards the
  beginning it may have non-linear effects way down the document)

- Typesetting is critically sensitive to small changes: every saved
  line counts

- It's hard to be greedy and pretty.

* Pretty-printing pearls: state of the pop-art

(a b c d)

or

(a
 b
 c
 d)

Example:

((abcde ((a b c d)
         (a b c d)
         (a b c d)
         (a b c d)
         (a b c d)))
 (abcdefgh
  ((a b c d)
   (a b c d)
   (a b c d)
   (a b c d)
   (a b c d))))

* Hughes

12345678901234567890

((abcde ((a b c d)
         (a b c d)
         (a b c d)
         (a b c d)
         (a b c d)))
 (abcdefgh ((a
             b
             c
             d)
            (a
             b
             c
             d)
            (a
             b
             c
             d)
            (a
             b
             c
             d)
            (a
             b
             c
             d))))

* Wadler

- Wadler:
  - will waste a line here and there
  - lack of "hang" feature

12345678901234567890

((abcde
  ((a b c d)
   (a b c d)
   (a b c d)
   (a b c d)
   (a b c d)))
 (abcdefgh
  ((a b c d)
   (a b c d)
   (a b c d)
   (a b c d)
   (a b c d))))

* Not satisfied

- I am not happy with any of the above

- What do I *really* want?

On the example:

((abcde ((a b c d)
         (a b c d)
         (a b c d)
         (a b c d)
         (a b c d)))
 (abcdefgh
  ((a b c d)
   (a b c d)
   (a b c d)
   (a b c d)
   (a b c d))))

In general?

* Laws of Pretty-Printing (paraphrased)
1. A pretty-printer shall not print beyond the right margin
2. A pretty-printer shall reveal the structure of the input
3. A pretty-printer shall use as few lines as possible

- Hughes breaks 3
- Wadler breaks 2

* What does rule 2 really mean?

- User-specified
- But it is clear that everyone (except Phil Wadler) wants to be able
  to express vertical alignment after an arbitrary document.

* Describing rule-2 layouts

class Layout l where
  (<>)    :: l -> l -> l
  text    :: String -> l
  flush   :: l -> l
  render  :: l -> String

class Layout d => Doc d where
  (<|>) :: d -> d -> d
  fail :: d

* Example:

#+BEGIN_SRC haskell
data SExpr = SExpr [SExpr] | Atom String
  deriving Show
#+END_SRC

#+BEGIN_SRC haskell
pretty :: Doc d => SExpr -> d
pretty  (Atom s)    = text s
pretty  (SExpr xs)  =   text "(" <>
                        (sep $ map pretty xs) <>
                        text ")"

sep :: Doc d => [d] -> d
sep []  = empty
sep xs  = hsep xs <|> vcat xs

hsep,vcat :: Doc d => [d] -> d
vcat  = foldDoc ($$)
hsep  = foldDoc (<+>)

foldDoc :: Doc d => (d -> d -> d) -> [d] -> d
foldDoc _ []      = empty
foldDoc _ [x]     = x
foldDoc f (x:xs)  = f x (foldDoc f xs)
#+END_SRC

* Semantics
#+BEGIN_SRC haskell
type L = [String] -- non empty.

instance Layout L where
  render :: L -> String
  render = intercalate "\n"
  text :: String -> L
  text s = [s]
  (<>) :: L -> L -> L
  xs <> (y:ys) = xs0 ++ [x ++ y] ++ map (indent ++) ys
     where  xs0 = init xs
            x :: String
            x = last xs
            n = length x
            indent = replicate n ' '
  flush :: L -> L
  flush xs = xs ++ [""]

xs $$ ys = flush xs <> ys

instance Layout [L] where
  text = pure . text
  flush = fmap flush
  xs <> ys = (<>) <$> xs <*> ys

instance Doc [L] where
  xs <|> ys = (xs ++ ys)
  fail = []
#+END_SRC

* Performance

Unacceptable performance: every choice induces two layouts.
Printing any document with >20 disjunctions is unrealistic.

* The useful parts
The choice of layout depends only on 3 parameters: width, height the
width of the last line.


             width
         <---------------->
         xxxxxxxxxxxxxxxxxx ^
         xxxxxxxxxxxxxxxxxx |  height
         xxxxxxxxxxxxxxxxxx v
         xxxxxxx
         <----->
        last width

* Domination

a dominates b iff. a is smaller in all three dimensions

If a dominates b, then for any context ctx,

   ctx a  dominates  ctx b

So, we can at any point we can discard all dominated layouts from the
set of possible layouts.

(proof in the paper)

* Experimental Results (asymptotic)
** Balanced
#+NAME: fig:balanced
#+CAPTION: Balanced tree
#+ATTR_ORG: :width 600
[[file:Balanced.png]]

** Random
#+NAME: fig:balanced
#+CAPTION: Balanced tree
#+ATTR_ORG: :width 600
[[file:Balanced.png]]

* Experimental Results (absolute)

| Input      |  Ours | Wadler-Leijen | Hughes-PJ |
|------------+-------+---------------+-----------|
| JSON   1k  |   9.7 |           1.5 |       3.0 |
| JSON   10k | 145.5 |          14.8 |      30.0 |
| XML    1k  |  20.0 |           3.2 |      11.9 |
| XML    10k | 245.0 |          36.1 |     192.0 |

Render time in seconds

* Conclusion

- Pretty-printing is not suited to greedy approach
- Yet, Hughes, Wadler went for a greedy algorithm.
- I suspect that they had a solution in mind *before* they start their
  program derivation.
- Attempt to do a more realistic FP pearl: bridge the gap between what
  actually goes on in programming (graphical models) and program calculation
