
* State of the art
  
- Hughes. Pretty, but makes eager decisions (sec. 7.4) so the results are ugly.
- Wadler. Much simpler, but produces even uglier things.

Let us detail these claims

Say we pretty print s-exps, and we allow for them to be printed either horizontally, or
vertically like so:
(a
 b
 c
 d)

(ie. we want the elements to be aligned on the 1st parens)

With Wadler we can implement this as:

vcat xs = foldr (<> line <>) nil
group $ "(" <> nest 1 (vcat xs) <> ")"

And we try to prettify:

(a b c (d e f))

in this width:
###########

We get:

(a
 b
 c
 (d e f))

but never the shorter:

###########
(a b c (d
        e
        f))

Indeed, it tries to fit the whole text on one line. This fails, so the
vertical option is chosen.


Hughes choses the prettier option, bu also suffers from the problem of
making eager decisions:

Consider:

(axbxcxd ((a b c d) (a b c d) (a b c d) (a b c d) (a b c d)))

To fit:
###############

Hughes tries to fit as much as possible on the 1st line. In this case, it succeeds:

###############
(axbxcxd ((a

But then, it has committed to this indentation level, and we get a
very long output:

###############
(axbxcxd ((a
           b
           c
           d)
          (a
           b
           c
           d)
          (a
           b
           c
           d)
          (a
           b
           c
           d)
          (a
           b
           c
           d)))
###############

While this choice could have been made:

###############
(axbxcxd
 ((a b c d)
  (a b c d)
  (a b c d)
  (a b c d)
  (a b c d))
###############

These examples may feel contrieved. In reality they occur all the
time.

Can we implement a library that choses always the prettiest layout?
Can we take the best possible choice, while not getting lost in
backtracking? Yep.

* Specification of the problem
** Syntax

spacing :: String -> Doc -- so we can use arbitrary characters as "spaces"; useful for example for haskell layout.
line :: Doc
nil :: Doc
(<>) :: Doc -> Doc -> Doc
text :: String -> Doc
nest :: Int -> Doc -> Doc
align :: Doc -> Doc
(<|>) :: Doc -> Doc -> Doc -- invariant: the two docs have the same contents:

contents (spacing _) = []
contents nil = []
contents line = []
contents (d1 <> d2) = contents d1 <> contents d2
contents (text x) = [x]
contents (align x) = contents x
contents (x <|> y) = contents x

** Semantics

layout :: Doc -> String

Define a interpretation of the combinators as a relation Doc ⟶ Layout
(aop style relations, folds, etc.)

For compositional semantics, a Layout is something rather complicated:

Layout = IndentLevel × Column → Text × Column × NumberOfLines

The column is necessary to implement alignment, which (locally) sets
the indentation level to the current column.

The evaluation relation can be defined as follows:

⟦text    s⟧ (i,c0) = (s,c0+len s)
⟦spacing s⟧ (i,c0) = (s,c0+len s)
nil (i,c) = ("",c,0)
⟦align d⟧ (i,c) = ⟦d⟧ (c,c,0)
⟦line⟧ (i,c) = ("\n", i)
⟦d1 <> d2⟧ (i,c) = let (t1,c1) = ⟦d1⟧ (i,c)
                       (t2,c2) = ⟦d2⟧ (i,c2)
                   in (t1 ++ t2, c2)
⟦nest n d⟧ (i,c) = ⟦d⟧ (i+n,c)
⟦d1 <|> d2⟧ (i,c) = ⟦d1⟧ (i,c)
                  = ⟦d2⟧ (i,c) 

-- two cases for group; so we have a relation.


A useful combinator (not part of the core) is the following:
flatten :: Doc -> Doc
flatten line  = nil
flatten nil = nil
flatten (text x) = text x
flatten (x <> y)        = flatten x <> flatten y
flatten (x <|> y)       = flatten x -- arbitrary choice
flatten (Nest i x)      = flatten x
flatten (group x)       = flatten x
flatten (align x)       = flatten x

For the purpose of the derivation, we can ignore the actual text, and
just recall its maximal width and number of lines.

We define the overflow to be the difference between the maximal width
and some constant w, the width of the page.

The goal is then to find the solution which has non positive overflow,
and returns the smallest number of lines.


** Some quickspec laws
text [] = empty

Size 3, 36 schemas to consider:
x <> empty = x
empty <> x = x
nest i empty = empty
nest 0 x = x

Size 4, 38 schemas to consider:
nest i (text xs) = text xs

Size 5, 107 schemas to consider:
text xs <> text ys = text (xs ++ ys)
(x <> y) <> z = x <> (y <> z)
nest i (nest j x) = nest j (nest i x)
nest (i + j) x = nest i (nest j x)

Size 6, 154 schemas to consider:
nest i (x <> text xs) = nest i x <> text xs
nest i (text xs <> x) = text xs <> nest i x

Size 7, 383 schemas to consider:
nest i x <> nest i y = nest i (x <> y)

Size 8, 722 schemas to consider:

Size 9, 1745 schemas to consider:

7179 events created in total (1295 schemas, 1027 terms, 4823 creation, 34 miscellaneous).
34 hooks installed.

== Signature ==
group :: Doc1 -> Doc1
align :: Doc1 -> Doc1

Size 1, 13 schemas to consider:

Size 2, 27 schemas to consider:
align empty = empty
group empty = empty

Size 3, 55 schemas to consider:
align (align x) = align x
align (group line) = group line
align (text xs) = text xs
group (align x) = align (group x)
group (group x) = group x
group (text xs) = text xs

Size 4, 108 schemas to consider:
line <> align x = line <> x
group (nest i line) = group line
nest i (align x) = align x
nest i (group x) = group (nest i x)

Size 5, 264 schemas to consider:
align line <> align x = align (line <> x)
align (x <> align y) = align x <> align y
align (align x <> y) = align (x <> y)
group (x <> text xs) = group x <> text xs
group (group line <> line) = group line <> group line
group (text xs <> x) = text xs <> group x

Size 6, 724 schemas to consider:
group (group x <> group y) = group x <> group y

* Derivation.
 TODO

The solution is to pretty-print line by line (so we consider only
shortest resuts).  We prune dominated solutions. Each solution is
assigned a pair (i,p) of current indentation (i) and progess (p).  The current
indentation is well defined, because we are at a given line. The
progress is the number of tokens that could be printed so far.

(i0,p0) > (i1,p1)  iff i0 < i1 and p0 >= p1

If there is a finite number (l) of indentation levels (traditionally
l=80), then we have only to consider l solutions after each line
break.

* Result

The algorithm has been implemented.
The result have been used sucessfully to pretty print code in papers;
allowing to fit more stuff than was possible using Wadler's approach.
